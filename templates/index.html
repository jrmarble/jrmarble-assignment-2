<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMeans Clustering Algorithm</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .plot {
            margin: 20px auto;
        }
        button {
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>KMeans Clustering Algorithm</h1>

    <label for="k-value">Number of Clusters (k): </label>
    <input id="k-value" type="number" value="3" min="1" max="10">

    <br><br>

    <label for="init-method">Initialization Method: </label>
    <select id="init-method">
        <option value="random">Random</option>
        <option value="farthest">Farthest First</option>
        <option value="kmeans++">KMeans++</option>
        <option value="manual">Manual</option>
    </select>

    <br><br>

    <button onclick="stepThroughKMeans()">Step Through KMeans</button>
    <button onclick="runToConvergence()">Run to Convergence</button>
    <button onclick="generateNewDataset()">Generate New Dataset</button>
    <button onclick="resetAlgorithm()">Reset Algorithm</button>

    <svg class="plot" width="500" height="500"></svg>

    <script>
        let dataPoints = [];
        let centroids = [];
        let clusters = [];
        let currentStep = 0; // Track the current step in the algorithm
        let isConverged = false; // Flag for convergence
        let maxIterations = 10; // Maximum iterations for KMeans
        let clusterColors = d3.schemeCategory10;
        const svg = d3.select(".plot");

        // Generate new dataset
        function generateNewDataset() {
            d3.json('/generate_dataset').then(data => {
                dataPoints = data;
                drawDataPoints();
                resetKMeansState();
            });
        }

        // Reset the KMeans algorithm state
        function resetKMeansState() {
            currentStep = 0;
            isConverged = false;
            centroids = [];
            clusters = [];
            drawDataPoints();
            svg.selectAll(".centroid").remove();
        }

        // Draw data points on the plot
        function drawDataPoints() {
            svg.selectAll("*").remove();
            svg.selectAll("circle")
                .data(dataPoints)
                .enter()
                .append("circle")
                .attr("cx", d => d[0] * 20 + 250)
                .attr("cy", d => d[1] * 20 + 250)
                .attr("r", 3)
                .style("fill", "steelblue");
        }

        // Step through the KMeans algorithm
        function stepThroughKMeans() {
            const k = document.getElementById('k-value').value;
            const initMethod = document.getElementById('init-method').value;

            if (isConverged || currentStep >= maxIterations) {
                alert("KMeans has converged or reached the maximum number of iterations.");
                return;
            }

            d3.json('/run_kmeans_step', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    k: k,
                    initMethod: initMethod,
                    data: dataPoints,
                    currentStep: currentStep
                })
            }).then(data => {
                centroids = data.centroids;
                clusters = data.clusters;
                isConverged = data.converged;
                currentStep += 1;

                // Update the plot with new centroids and clusters
                drawCentroids();
                updateClusters(clusters);
            });
        }

        // Draw the centroids on the plot
        function drawCentroids() {
            svg.selectAll(".centroid").remove();
            svg.selectAll(".centroid")
                .data(centroids)
                .enter()
                .append("circle")
                .attr("cx", d => d[0] * 20 + 250)
                .attr("cy", d => d[1] * 20 + 250)
                .attr("r", 7) // Larger radius for centroids
                .style("fill", "red")
                .attr("class", "centroid");
        }

        // Update clusters by coloring data points based on their cluster assignment
        function updateClusters(clusters) {
            svg.selectAll("circle")
                .data(dataPoints)
                .transition() // Smooth transition for cluster updates
                .duration(500)
                .attr("fill", (d, i) => clusterColors[clusters[i]]);
        }

        // Run KMeans to convergence by stepping through each iteration
        function runToConvergence() {
            const interval = setInterval(() => {
                if (isConverged || currentStep >= maxIterations) {
                    clearInterval(interval); // Stop if converged or max iterations reached
                } else {
                    stepThroughKMeans();
                }
            }, 1000); // Run one step per second
        }

        // Reset the algorithm and plot
        function resetAlgorithm() {
            resetKMeansState();
        }

        // Generate the initial dataset on load
        generateNewDataset();
    </script>
</body>
</html>
