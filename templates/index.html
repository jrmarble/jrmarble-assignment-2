<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMeans Clustering</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .plot {
            margin: 20px auto;
        }
        button {
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>KMeans Clustering Algorithm</h1>
    
    <label for="k-value">Number of Clusters (k): </label>
    <input id="k-value" type="number" value="3" min="1" max="10">
    
    <br><br>
    
    <label for="init-method">Initialization Method: </label>
    <select id="init-method">
        <option value="random">Random</option>
        <option value="farthest">Farthest First</option>
        <option value="kmeans++">KMeans++</option>
        <option value="manual">Manual</option>
    </select>
    
    <br><br>
    
    <button onclick="generateNewDataset()">Generate New Dataset</button>
    <button onclick="stepThroughKMeans()">Step Through KMeans</button>
    <button onclick="runToConvergence()">Run to Convergence</button>
    <button onclick="resetAlgorithm()">Reset Algorithm</button>
    
    <svg class="plot" width="500" height="500"></svg>

    <script>
        let dataPoints = [];
        let centroids = [];
        let manualCentroids = [];
        let isManualInit = false;
        let clusterColors = d3.schemeCategory10; // Use D3's color scheme for clusters
        const svg = d3.select(".plot");

        // Generate new dataset
        function generateNewDataset() {
            d3.json('/generate_dataset').then(data => {
                dataPoints = data;
                drawDataPoints();
            });
        }

        // Draw data points on the plot
        function drawDataPoints() {
            svg.selectAll("*").remove();
            svg.selectAll("circle")
                .data(dataPoints)
                .enter()
                .append("circle")
                .attr("cx", d => d[0] * 20 + 250)
                .attr("cy", d => d[1] * 20 + 250)
                .attr("r", 3)
                .style("fill", "steelblue");
        }

        // Step through KMeans clustering with selected initialization method
        function stepThroughKMeans() {
            const k = document.getElementById('k-value').value;
            const initMethod = document.getElementById('init-method').value;

            // If manual method is selected, enable manual initialization
            if (initMethod === 'manual') {
                enableManualInit();
                return;
            }

            // Otherwise, proceed with normal initialization
            d3.json('/run_kmeans', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    k: k,
                    initMethod: initMethod,
                    data: dataPoints
                })
            }).then(data => {
                centroids = data.centroids;
                drawCentroids();
                updateClusters(data.clusters);  // Call to color points based on clusters
            });
        }

        // Enable manual initialization
        function enableManualInit() {
            manualCentroids = [];
            isManualInit = true;
            d3.select(".plot").on("click", addManualCentroid);
        }

        // Add a centroid at the click location
        function addManualCentroid() {
            if (!isManualInit) return;
            
            const [x, y] = d3.mouse(this);
            const scaledX = (x - 250) / 20;
            const scaledY = (y - 250) / 20;

            manualCentroids.push([scaledX, scaledY]);
            drawManualCentroid(x, y);

            const k = document.getElementById('k-value').value;
            if (manualCentroids.length === parseInt(k)) {
                isManualInit = false;
                d3.select(".plot").on("click", null);
                runKMeansWithManualCentroids();
            }
        }

        // Draw the manually selected centroid
        function drawManualCentroid(x, y) {
            svg.append("circle")
                .attr("cx", x)
                .attr("cy", y)
                .attr("r", 5)
                .style("fill", "red")
                .attr("class", "manual-centroid");
        }

        // Run KMeans using the manually selected centroids
        function runKMeansWithManualCentroids() {
            const k = document.getElementById('k-value').value;
            
            d3.json('/run_kmeans', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    k: k,
                    initMethod: 'manual',
                    data: dataPoints,
                    manualCentroids: manualCentroids
                })
            }).then(data => {
                centroids = data.centroids;
                drawCentroids();
                updateClusters(data.clusters);  // Update clusters for visualization
            });
        }

        // Draw centroids
        function drawCentroids() {
            svg.selectAll(".centroid").remove();
            svg.selectAll(".centroid")
                .data(centroids)
                .enter()
                .append("circle")
                .attr("cx", d => d[0] * 20 + 250)
                .attr("cy", d => d[1] * 20 + 250)
                .attr("r", 7)  // Larger radius for centroids
                .style("fill", "red")
                .attr("class", "centroid");
        }

        // Update clusters by coloring data points based on their cluster assignment
        function updateClusters(clusters) {
            svg.selectAll("circle")
                .data(dataPoints)
                .transition()  // Smooth transition for color change
                .duration(500)
                .attr("fill", (d, i) => clusterColors[clusters[i]]);  // Color points based on cluster
        }

        // Run KMeans to convergence
        function runToConvergence() {
            stepThroughKMeans();
        }

        // Reset the algorithm and plot
        function resetAlgorithm() {
            svg.selectAll("*").remove();
            dataPoints = [];
            centroids = [];
        }

        // Generate initial dataset on load
        generateNewDataset();
    </script>
</body>
</html>
